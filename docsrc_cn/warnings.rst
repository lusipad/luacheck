警告列表
========

Luacheck 产生的警告使用三位数字警告代码进行分类。可以使用 ``--codes`` CLI 选项或 ``codes`` 配置选项在 CLI 输出中显示警告代码。错误也有以零开头的代码；与警告不同，它们不能被忽略。

==== =============================================================================
代码  描述
==== =============================================================================
011  语法错误。
021  无效的内联选项。
022  不成对的内联推送指令。
023  不成对的内联弹出指令。
111  设置未定义的全局变量。
112  修改未定义的全局变量。
113  访问未定义的全局变量。
121  设置只读全局变量。
122  设置全局变量的只读字段。
131  未使用的隐式定义的全局变量。
142  设置全局变量的未定义字段。
143  访问全局变量的未定义字段。
211  未使用的局部变量。
212  未使用的参数。
213  未使用的循环变量。
221  局部变量被访问但从未设置。
231  局部变量被设置但从未访问。
232  参数被设置但从未访问。
233  循环变量被设置但从未访问。
241  局部变量被修改但从未访问。
311  分配给局部变量的值未使用。
312  参数的值未使用。
313  循环变量的值未使用。
314  表字面量中的字段的值未使用。
321  访问未初始化的局部变量。
331  分配给局部变量的值被修改但从未访问。
341  修改未初始化的局部变量。
411  重新定义局部变量。
412  重新定义参数。
413  重新定义循环变量。
421  遮蔽局部变量。
422  遮蔽参数。
423  遮蔽循环变量。
431  遮蔽上值。
432  遮蔽上值参数。
433  遮蔽上值循环变量。
511  不可达代码。
512  循环最多只能执行一次。
521  未使用的标签。
531  赋值的左侧太短。
532  赋值的左侧太长。
541  空的 ``do`` ``end`` 块。
542  空的 ``if`` 分支。
551  空语句。
561  函数的圈复杂度过高。
571  数值 for 循环从 #(expr) 向下到 1 或更小，但没有负步长。
611  行只包含空白字符。
612  行包含尾随空白字符。
613  字符串中的尾随空白字符。
614  注释中的尾随空白字符。
621  不一致的缩进（``SPACE`` 后跟 ``TAB``）。
631  行过长。
==== =============================================================================

全局变量 (1xx)
--------------

对于每个文件，Luacheck 构建可以在其中使用的已定义全局变量和字段的列表。默认情况下只定义 Lua 标准库的全局变量；可以使用 ``--globals`` CLI 选项或 ``globals`` 配置选项添加自定义全局变量，标准库的版本可以使用 ``--std`` CLI 选项或 ``std`` 配置选项选择。当设置、修改或访问未定义的全局变量或字段时，Luacheck 会产生警告。

只读全局变量
^^^^^^^^^^^^

默认情况下，大多数标准全局变量和字段都标记为只读，因此设置它们会产生警告。可以使用 ``--read-globals`` CLI 选项或 ``read_globals`` 配置选项添加自定义只读全局变量和字段，或使用自定义全局变量集。见 :ref:`custom_stds`

默认情况下不是只读的全局变量和字段：

* ``_G``
* ``_ENV``（被 Luacheck 视为全局变量）
* ``package.path``
* ``package.cpath``
* ``package.loaded``
* ``package.preload``
* ``package.loaders``
* ``package.searchers``

.. _implicitlydefinedglobals:

隐式定义的全局变量
^^^^^^^^^^^^^^^^^^

Luacheck 可以配置为将在某些条件下分配的全局变量视为隐式定义。当使用 ``-d``/``--allow-defined`` CLI 选项或 ``allow_defined`` 配置选项时，所有对全局变量的赋值都会定义它们；当使用 ``-t``/``--allow-defined-top`` CLI 选项或 ``allow_defined_top`` 配置选项时，在顶层函数作用域（也称为主块）中对全局变量的赋值会定义它们。当隐式定义的全局变量在任何地方都没有被访问时，会产生警告。

.. _modules:

模块
^^^^

文件可以使用 ``-m``/``--module`` CLI 选项或 ``module`` 配置选项标记为模块，以模拟已弃用的 `module <http://www.lua.org/manual/5.1/manual.html#pdf-module>`_ 函数的语义。模块内隐式定义的全局变量被视为其接口的一部分，在外部不可见，并且不会被报告为未使用。不允许对其他全局变量赋值，即使是已定义的。

未使用的变量 (2xx) 和值 (3xx)
----------------------------

Luacheck 为所有未使用的局部变量生成警告，除了名为 ``_`` 的变量。它还检测被设置但从未访问或被访问但从未设置的变量。

未使用的值和未初始化的变量
^^^^^^^^^^^^^^^^^^^^^^^^^^

对于分配给局部变量的每个值，Luacheck 计算可能使用它的表达式集合。对于未使用的值（当值不能在任何地方使用时）和访问未初始化的变量（当没有值可以到达表达式时）会产生警告。例如，在以下代码段中，第 1 行分配给 ``foo`` 的值未使用，第 9 行的变量 ``bar`` 未初始化：

.. code-block:: lua
   :linenos:

   local foo = expr1()
   local bar

   if condition() then
      foo = expr2()
      bar = expr3()
   else
      foo = expr4()
      print(bar)
   end

   return foo, bar

.. _secondaryvaluesandvariables:

次要值和变量
^^^^^^^^^^^^

分配给局部变量的未使用值是次要的，如果它的来源是赋值 RHS 上的最后一项，并且该项中的另一个值被使用。次要值通常出现在函数调用的结果放入局部变量时，并且只有其中一些稍后被使用。例如，这里分配给 ``b`` 的值是次要的，分配给 ``c`` 的值被使用，分配给 ``a`` 的值只是未使用：

.. code-block:: lua
   :linenos:

   local a, b, c = f(), g()

   return c

如果分配给变量的所有值都是次要的，则该变量是次要的。在上面的代码段中，``b`` 是一个次要变量。

可以使用 ``-s``/``--no-unused-secondaries`` CLI 选项或 ``unused_secondaries`` 配置选项移除与未使用的次要值和变量相关的警告。

遮蔽声明 (4xx)
--------------

Luacheck 检测遮蔽先前声明的局部变量声明，除非变量名为 ``_``。如果先前的声明与新声明在同一作用域中，则称为重新定义。

请注意，覆盖参数时**不必**定义新的局部变量：

.. code-block:: lua
   :linenos:

   local function f(x)
      local x = x or "default" -- 不好
   end

   local function f(x)
      x = x or "default" -- 好
   end

控制流和数据流问题 (5xx)
------------------------

不可达代码
^^^^^^^^^^

Luacheck 检测不可达代码。它还检测循环块的结束是否不可达，这意味着循环最多只能执行一次：

.. code-block:: lua
   :linenos:

   for i = 1, 100 do
      -- Break 语句在 `if` 块之外，
      -- 因此循环总是在第一次迭代后停止。
      if cond(i) then f() end break
   end

未使用的标签
^^^^^^^^^^^^

未被任何 ``goto`` 语句使用的标签被报告为未使用。

不平衡的赋值
^^^^^^^^^^^^

如果赋值的左侧和右侧长度不同，则赋值不平衡，Luacheck 会发出警告。

一个例外是在单个语句中初始化多个局部变量，同时使一些保持未初始化状态：

.. code-block:: lua
   :linenos:

   local a, b, c = nil -- 有效地将 `a`、`b` 和 `c` 设置为 nil，没有警告。

空块
^^^^

Luacheck 警告空的 ``do`` ``end`` 块和空的 ``if`` 分支（``then`` ``else``、``then`` ``elseif`` 和 ``then`` ``end``）。

空语句
^^^^^^

在 Lua 5.2+ 中，分号被视为语句，即使不跟随正常语句也可以出现。这样的分号
会产生 Luacheck 警告，因为它们完全无用。

圈复杂度
^^^^^^^^

如果使用 ``--max-cyclomatic-complexity`` CLI 选项或相应的配置或内联选项设置了限制，Luacheck 会警告
圈复杂度过高的函数。

反向数值 for 循环
^^^^^^^^^^^^^^^^^

使用从 ``#t`` 到 ``1`` 的数值 for 循环反向迭代表需要负的循环步长。Luacheck 警告从 ``#(某个表达式)`` 到 ``1`` 或更小常量的循环，当循环步长不为负时：

.. code-block:: lua
   :linenos:

   -- 此循环的警告：
   -- 数值 for 循环从 #(expr) 向下到 1 但循环步长不为负
   for i = #t, 1 do
      print(t[i])
   end

   -- 此循环正常。
   for i = #t, 1, -1 do
      print(t[i])
   end

格式问题 (6xx)
--------------

空白问题
^^^^^^^^

Luacheck 警告尾随空白字符和不一致的缩进（``SPACE`` 后跟 ``TAB``）。

Luacheck 发现的一些尾随空白示例：

.. code-block:: lua
   :linenos:

   -- 空白示例。
   print("Hello")

   print("World")

这里：

* 任一 ``)`` 之后的任何制表符或空格都将被视为尾随。
* 注释中 ``.`` 之后的任何制表符或空格都将被视为尾随
* 两个 ``print`` 语句之间空行上的任何制表符或空格也将被视为尾随空白的一种形式。

任何这些形式的尾随空白都是无用的，可能会给在文件中导航的开发者带来困扰，并且在许多格式样式中都是被禁止的。

行长度限制
^^^^^^^^^^

Luacheck 警告长于某个限制的行。默认限制是 ``120`` 个字符。可以使用 ``--max-line-length`` CLI 选项更改此限制，或使用 ``--no-max-line-length`` 完全禁用检查；
有类似的配置和内联选项。

此外，可以为三种不同类型的行设置单独的限制：

* "字符串"行的行结束符在字符串内，通常是使用 ``[[...]]`` 语法的长字符串。
* "注释"行的行结束符在长注释（``--[[...]]``）内，或以正常的 ``--...`` 语法以短注释结束。
* "代码"行是所有其他行。

这些类型的行使用名为 ``--[no-]max-string-line-length``、``--[no-]max-comment-line-length``
和 ``--[no-]max-code-line-length`` 的 CLI 选项进行限制，具有类似的配置和内联选项。